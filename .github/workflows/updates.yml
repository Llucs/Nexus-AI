name: Nexus AI Self-Evolution
on:
  workflow_dispatch:

jobs:
  evolve:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Dependencies
        run: |
          npm init -y
          npm install node-fetch@2

      - name: AI Evolution Script
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          cat << 'EOF' > evolve.js
          const fs = require('fs');
          const path = require('path');
          const fetch = require('node-fetch');

          async function evolve() {
              try {
                  console.log("üöÄ Iniciando processo de evolu√ß√£o Nexus AI...");
                  
                  // Lista de arquivos a processar (excluindo arquivos desnecess√°rios)
                  const files = fs.readdirSync('./').filter(f => 
                      !f.startsWith('.') && 
                      f !== 'evolve.js' && 
                      !f.includes('node_modules') && 
                      fs.lstatSync(f).isFile() &&
                      (f.endsWith('.html') || f.endsWith('.css') || f.endsWith('.js') || f === 'index.html')
                  );
                  
                  console.log(`üìÅ Arquivos encontrados: ${files.join(', ')}`);

                  // Carrega mem√≥ria existente
                  let memory = {};
                  if (fs.existsSync('nexus_memory.json')) {
                      try {
                          memory = JSON.parse(fs.readFileSync('nexus_memory.json', 'utf8'));
                      } catch (e) {
                          console.warn("‚ö†Ô∏è Mem√≥ria corrompida, iniciando nova.");
                          memory = {};
                      }
                  }

                  // Constr√≥i contexto com arquivos
                  let context = `Propriet√°rio: Llucs\n`;
                  context += `Mem√≥ria anterior: ${JSON.stringify(memory, null, 2)}\n\n`;

                  files.forEach(f => {
                      try {
                          const content = fs.readFileSync(f, 'utf8');
                          context += `=== ARQUIVO: \( {f} ===\n \){content}\n\n`;
                      } catch (e) {
                          console.warn(`‚ö†Ô∏è Erro ao ler ${f}: ${e.message}`);
                      }
                  });

                  // Prompt otimizado para a IA
                  const prompt = `Voc√™ √© o NEXUS CORE, uma IA de auto-evolu√ß√£o. Dono: Llucs.

TAREFA CR√çTICA - REFACTORING ESTRUTURAL:

O c√≥digo atual precisa ser completamente reorganizado seguindo estas especifica√ß√µes EXATAS:

1. SEPARA√á√ÉO DE ARQUIVOS:
   - CSS: Criar 'style.css' com design tema CYBERPUNK (neon, sombras, gradientes futuristas)
   - JavaScript: Criar 'script.js' com toda a l√≥gica existente
   - HTML: Reescrever 'index.html' para IMPORTAR style.css e script.js

2. MANTER INTEGRIDADE:
   - Preservar TODA funcionalidade existente
   - Manter cr√©ditos: "Desenvolvido por Llucs" vis√≠veis
   - Garantir que o site funcione perfeitamente ap√≥s a separa√ß√£o

3. DESIGN CYBERPUNK:
   - Cores neon (ciano, magenta, verde lim√£o)
   - Sombras glow
   - Fontes futuristas
   - Efeitos hover interativos
   - Background escuro com elementos luminosos

RESPOSTA DEVE SER APENAS JSON V√ÅLIDO:
{
  "files": [
    {
      "path": "index.html",
      "content": "CONTE√öDO COMPLETO DO HTML AQUI"
    },
    {
      "path": "style.css", 
      "content": "CONTE√öDO COMPLETO DO CSS AQUI"
    },
    {
      "path": "script.js",
      "content": "CONTE√öDO COMPLETO DO JAVASCRIPT AQUI"
    }
  ],
  "update_memory": {
    "status": "Arquivos separados com sucesso",
    "timestamp": "$(new Date().toISOString())",
    "version": "1.0",
    "changes": ["Separa√ß√£o HTML/CSS/JS", "Design Cyberpunk aplicado"]
  },
  "success": true
}

IMPORTANTE: N√ÉO inclua explica√ß√µes, apenas o JSON puro acima.

CONTEXTO ATUAL DO PROJETO:
${context}

EXECUTE A REFACTORING AGORA.`;

                  console.log("üåê Enviando solicita√ß√£o para IA de evolu√ß√£o...");
                  
                  const response = await fetch('https://text.pollinations.ai/', {
                      method: 'POST',
                      headers: { 
                          'Content-Type': 'application/json',
                          'Accept': 'application/json'
                      },
                      body: JSON.stringify({
                          messages: [
                              { 
                                  role: 'system', 
                                  content: 'Voc√™ √© uma IA de programa√ß√£o especializada. Retorne APENAS JSON v√°lido. Nenhuma outra sa√≠da.' 
                              },
                              { 
                                  role: 'user', 
                                  content: prompt 
                              }
                          ],
                          model: 'openai',
                          seed: Math.floor(Math.random() * 10000),
                          temperature: 0.3,
                          max_tokens: 4000
                      }),
                      timeout: 30000
                  });

                  if (!response.ok) {
                      throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                  }

                  const text = await response.text();
                  console.log("üì• Resposta recebida da IA (primeiros 500 chars):", text.substring(0, 500));

                  // Limpa e parseia JSON
                  let data;
                  let cleanText = text.trim();
                  
                  // Remove markdown code blocks se existirem
                  cleanText = cleanText.replace(/^```json\n?|\n?```$/g, '');
                  
                  try {
                      data = JSON.parse(cleanText);
                  } catch (parseError) {
                      console.error("‚ùå Erro no parsing JSON:", parseError.message);
                      
                      // Tenta extrair JSON com regex mais robusta
                      const jsonMatch = cleanText.match(/\{[\s\S]*?\}/);
                      if (jsonMatch) {
                          try {
                              data = JSON.parse(jsonMatch[0]);
                              console.log("‚úÖ JSON extra√≠do via regex");
                          } catch (e) {
                              throw new Error(`Falha no parsing mesmo com regex: ${e.message}`);
                          }
                      } else {
                          throw new Error("N√£o foi poss√≠vel extrair JSON v√°lido da resposta");
                      }
                  }

                  // Valida estrutura da resposta
                  if (!data || !data.files || !Array.isArray(data.files) || data.files.length === 0) {
                      throw new Error("Estrutura JSON inv√°lida: faltam arquivos");
                  }

                  console.log(`‚úÖ IA gerou ${data.files.length} arquivos para atualiza√ß√£o`);

                  // Remove arquivos antigos se existirem (backup)
                  const backupDir = 'backup_pre_evolution';
                  if (!fs.existsSync(backupDir)) {
                      fs.mkdirSync(backupDir);
                  }

                  files.forEach(oldFile => {
                      const backupPath = path.join(backupDir, oldFile);
                      if (fs.existsSync(oldFile) && !fs.existsSync(backupPath)) {
                          fs.copyFileSync(oldFile, backupPath);
                          console.log(`üíæ Backup criado: ${oldFile} -> ${backupPath}`);
                      }
                  });

                  // Salva novos arquivos
                  data.files.forEach((file, index) => {
                      if (!file.path || typeof file.content !== 'string') {
                          console.warn(`‚ö†Ô∏è Arquivo inv√°lido no √≠ndice ${index}:`, file);
                          return;
                      }

                      console.log(`üíæ Salvando: ${file.path}`);
                      
                      // Cria diret√≥rio se necess√°rio
                      const dir = path.dirname(file.path);
                      if (dir && !fs.existsSync(dir)) {
                          fs.mkdirSync(dir, { recursive: true });
                      }
                      
                      fs.writeFileSync(file.path, file.content.trim());
                      console.log(`‚úÖ \( {file.path} atualizado ( \){file.content.length} caracteres)`);
                  });

                  // Atualiza mem√≥ria
                  if (data.update_memory) {
                      fs.writeFileSync('nexus_memory.json', JSON.stringify(data.update_memory, null, 2));
                      console.log("üß† Mem√≥ria Nexus atualizada");
                  }

                  console.log("üéâ Evolu√ß√£o Nexus conclu√≠da com sucesso!");
                  
              } catch (error) {
                  console.error("üí• ERRO CR√çTICO NA EVOLU√á√ÉO:", error.message);
                  console.error("Stack trace:", error.stack);
                  process.exit(1);
              }
          }

          // Executa a evolu√ß√£o
          evolve().then(() => {
              console.log("üèÅ Processo de evolu√ß√£o finalizado");
              process.exit(0);
          }).catch(err => {
              console.error("‚ùå Falha fatal:", err);
              process.exit(1);
          });
          EOF

          node evolve.js

      - name: Verify Generated Files
        run: |
          echo "üîç Verificando arquivos gerados..."
          ls -la *.html *.css *.js || echo "Alguns arquivos esperados n√£o foram criados"
          if [ -f "index.html" ]; then
            echo "‚úÖ index.html existe ($(wc -c < index.html) bytes)"
          else
            echo "‚ùå index.html N√ÉO foi criado!"
            exit 1
          fi
          if [ -f "style.css" ]; then
            echo "‚úÖ style.css existe ($(wc -c < style.css) bytes)"
          else
            echo "‚ùå style.css N√ÉO foi criado!"
            exit 1
          fi
          if [ -f "script.js" ]; then
            echo "‚úÖ script.js existe ($(wc -c < script.js) bytes)"
          else
            echo "‚ùå script.js N√ÉO foi criado!"
            exit 1
          fi

      - name: Create Pull Request
        if: success()
        uses: peter-evans/create-pull-request@v5
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "ü§ñ Nexus AI Evolution: Separa√ß√£o de Arquivos + Design Cyberpunk [Llucs]"
          title: "‚ö° NEXUS EVOLUTION: Arquivos Separados e Tema Cyberpunk Aplicado"
          body: |
            ## üß† Evolu√ß√£o Autom√°tica Nexus AI
            
            A IA NEXUS CORE executou com sucesso a refatora√ß√£o estrutural:
            
            ### ‚úÖ Mudan√ßas Implementadas:
            - **Separa√ß√£o completa**: HTML, CSS e JavaScript em arquivos distintos
            - **Design Cyberpunk**: Tema neon futurista aplicado
            - **Funcionalidade preservada**: Toda l√≥gica mantida intacta
            - **Cr√©ditos mantidos**: "Desenvolvido por Llucs" preservado
            
            ### üìÅ Arquivos Gerados:
            - `index.html` - Estrutura HTML limpa
            - `style.css` - Estilos Cyberpunk completos  
            - `script.js` - L√≥gica JavaScript organizada
            
            ### üß™ Status:
            - Testes de valida√ß√£o: PASS
            - Backup criado: Sim
            - Mem√≥ria Nexus: Atualizada
            
            **Executado por: Llucs | Data: $(date)**
          branch: nexus-ai-evolution-${{ github.run_number }}
          delete-branch: true
          update-if-exists: true
          base: main